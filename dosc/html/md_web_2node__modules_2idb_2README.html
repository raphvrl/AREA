<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AREA: IndexedDB with usability.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AREA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">IndexedDB with usability.</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md14698"></a> This is a tiny (~1.06kB brotli'd) library that mostly mirrors the IndexedDB API, but with small improvements that make a big difference to usability.</p>
<ol type="1">
<li><a class="el" href="md_web_2node__modules_2web-vitals_2README.html#installation">Installation</a></li>
</ol>
<ol type="1">
<li>Changes</li>
</ol>
<ol type="1">
<li>Browser support</li>
</ol>
<ol type="1">
<li>API<ol type="a">
<li>`openDB`</li>
</ol>
<ol type="a">
<li>`deleteDB`</li>
</ol>
<ol type="a">
<li>`unwrap`</li>
</ol>
<ol type="a">
<li>`wrap`</li>
</ol>
<ol type="a">
<li>General enhancements</li>
</ol>
<ol type="a">
<li>`IDBDatabase` enhancements</li>
</ol>
<ol type="a">
<li>`IDBTransaction` enhancements</li>
</ol>
<ol type="a">
<li>`IDBCursor` enhancements</li>
</ol>
<ol type="a">
<li>Async iterators</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Examples</li>
</ol>
<ol type="1">
<li>TypeScript</li>
</ol>
<h1><a class="anchor" id="autotoc_md14699"></a>
Installation</h1>
<h2><a class="anchor" id="autotoc_md14700"></a>
Using npm</h2>
<div class="fragment"><div class="line">npm install idb</div>
</div><!-- fragment --><p>Then, assuming you're using a module-compatible system (like webpack, Rollup etc):</p>
<div class="fragment"><div class="line">import { openDB, deleteDB, wrap, unwrap } from &#39;idb&#39;;</div>
<div class="line"> </div>
<div class="line">async function doDatabaseStuff() {</div>
<div class="line">  const db = await openDB(…);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14701"></a>
Directly in a browser</h2>
<h3><a class="anchor" id="autotoc_md14702"></a>
Using the modules method directly via jsdelivr:</h3>
<div class="fragment"><div class="line">&lt;script type=&quot;module&quot;&gt;</div>
<div class="line">  import { openDB, deleteDB, wrap, unwrap } from &#39;https://cdn.jsdelivr.net/npm/idb@7/+esm&#39;;</div>
<div class="line"> </div>
<div class="line">  async function doDatabaseStuff() {</div>
<div class="line">    const db = await openDB(…);</div>
<div class="line">  }</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14703"></a>
Using external script reference</h3>
<div class="fragment"><div class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/idb@7/build/umd.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script&gt;</div>
<div class="line">  async function doDatabaseStuff() {</div>
<div class="line">    const db = await idb.openDB(…);</div>
<div class="line">  }</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><p>A global, <code>idb</code>, will be created, containing all exports of the module version.</p>
<h1><a class="anchor" id="autotoc_md14704"></a>
Changes</h1>
<p><a class="el" href="md_web_2node__modules_2idb_2CHANGELOG.html">See details of (potentially) breaking changes</a>.</p>
<h1><a class="anchor" id="autotoc_md14705"></a>
Browser support</h1>
<p>This library targets modern browsers, as in Chrome, Firefox, Safari, and other browsers that use those engines, such as Edge. IE is not supported.</p>
<p>If you want to target much older versions of those browsers, you can transpile the library using something like <a href="https://babeljs.io/">Babel</a>. You can't transpile the library for IE, as it relies on a proper implementation of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">JavaScript proxies</a>.</p>
<h1><a class="anchor" id="autotoc_md14706"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md14707"></a>
<code>openDB</code></h2>
<p>This method opens a database, and returns a promise for an enhanced <a href="https://w3c.github.io/IndexedDB/#database-interface"><code>IDBDatabase</code></a>.</p>
<div class="fragment"><div class="line">const db = await openDB(name, version, {</div>
<div class="line">  upgrade(db, oldVersion, newVersion, transaction, event) {</div>
<div class="line">    // …</div>
<div class="line">  },</div>
<div class="line">  blocked(currentVersion, blockedVersion, event) {</div>
<div class="line">    // …</div>
<div class="line">  },</div>
<div class="line">  blocking(currentVersion, blockedVersion, event) {</div>
<div class="line">    // …</div>
<div class="line">  },</div>
<div class="line">  terminated() {</div>
<div class="line">    // …</div>
<div class="line">  },</div>
<div class="line">});</div>
</div><!-- fragment --><ul>
<li><code>name</code>: Name of the database.</li>
<li><code>version</code> (optional): Schema version, or <code>undefined</code> to open the current version.</li>
<li><code>upgrade</code> (optional): Called if this version of the database has never been opened before. Use it to specify the schema for the database. This is similar to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest/upgradeneeded_event"><code>upgradeneeded</code> event</a> in plain IndexedDB.<ul>
<li><code>db</code>: An enhanced <code>IDBDatabase</code>.</li>
<li><code>oldVersion</code>: Last version of the database opened by the user.</li>
<li><code>newVersion</code>: Whatever new version you provided.</li>
<li><code>transaction</code>: An enhanced transaction for this upgrade. This is useful if you need to get data from other stores as part of a migration.</li>
<li><code>event</code>: The event object for the associated <code>upgradeneeded</code> event.</li>
</ul>
</li>
<li><code>blocked</code> (optional): Called if there are older versions of the database open on the origin, so this version cannot open. This is similar to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest/blocked_event"><code>blocked</code> event</a> in plain IndexedDB.<ul>
<li><code>currentVersion</code>: Version of the database that's blocking this one.</li>
<li><code>blockedVersion</code>: The version of the database being blocked (whatever version you provided to <code>openDB</code>).</li>
<li><code>event</code>: The event object for the associated <code>blocked</code> event.</li>
</ul>
</li>
<li><code>blocking</code> (optional): Called if this connection is blocking a future version of the database from opening. This is similar to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/versionchange_event"><code>versionchange</code> event</a> in plain IndexedDB.<ul>
<li><code>currentVersion</code>: Version of the open database (whatever version you provided to <code>openDB</code>).</li>
<li><code>blockedVersion</code>: The version of the database that's being blocked.</li>
<li><code>event</code>: The event object for the associated <code>versionchange</code> event.</li>
</ul>
</li>
<li><code>terminated</code> (optional): Called if the browser abnormally terminates the connection, but not on regular closures like calling <code>db.close()</code>. This is similar to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/close_event"><code>close</code> event</a> in plain IndexedDB.</li>
</ul>
<h2><a class="anchor" id="autotoc_md14708"></a>
<code>deleteDB</code></h2>
<p>Deletes a database.</p>
<div class="fragment"><div class="line">await deleteDB(name, {</div>
<div class="line">  blocked() {</div>
<div class="line">    // …</div>
<div class="line">  },</div>
<div class="line">});</div>
</div><!-- fragment --><ul>
<li><code>name</code>: Name of the database.</li>
<li><code>blocked</code> (optional): Called if the database already exists and there are open connections that don’t close in response to a versionchange event, the request will be blocked until they all close.<ul>
<li><code>currentVersion</code>: Version of the database that's blocking the delete operation.</li>
<li><code>event</code>: The event object for the associated 'versionchange' event.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md14709"></a>
<code>unwrap</code></h2>
<p>Takes an enhanced IndexedDB object and returns the plain unmodified one.</p>
<div class="fragment"><div class="line">const unwrapped = unwrap(wrapped);</div>
</div><!-- fragment --><p>This is useful if, for some reason, you want to drop back into plain IndexedDB. Promises will also be converted back into <code>IDBRequest</code> objects.</p>
<h2><a class="anchor" id="autotoc_md14710"></a>
<code>wrap</code></h2>
<p>Takes an IDB object and returns a version enhanced by this library.</p>
<div class="fragment"><div class="line">const wrapped = wrap(unwrapped);</div>
</div><!-- fragment --><p>This is useful if some third party code gives you an <code>IDBDatabase</code> object and you want it to have the features of this library.</p>
<p>This doesn't work with <code>IDBCursor</code>, <a href="https://github.com/w3c/IndexedDB/issues/255">due to missing primitives</a>. Also, if you wrap an <code>IDBTransaction</code>, <code>tx.store</code> and <code>tx.objectStoreNames</code> won't work in Edge. To avoid these issues, wrap the <code>IDBDatabase</code> object, and use the wrapped object to create a new transaction.</p>
<h2><a class="anchor" id="autotoc_md14711"></a>
General enhancements</h2>
<p>Once you've opened the database the API is the same as IndexedDB, except for a few changes to make things easier.</p>
<p>Firstly, any method that usually returns an <code>IDBRequest</code> object will now return a promise for the result.</p>
<div class="fragment"><div class="line">const store = db.transaction(storeName).objectStore(storeName);</div>
<div class="line">const value = await store.get(key);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14712"></a>
Promises &amp; throwing</h3>
<p>The library turns all <code>IDBRequest</code> objects into promises, but it doesn't know in advance which methods may return promises.</p>
<p>As a result, methods such as <code>store.put</code> may throw instead of returning a promise.</p>
<p>If you're using async functions, there's no observable difference.</p>
<h3><a class="anchor" id="autotoc_md14713"></a>
Transaction lifetime</h3>
<p>TL;DR: <b>Do not <code>await</code> other things between the start and end of your transaction</b>, otherwise the transaction will close before you're done.</p>
<p>An IDB transaction auto-closes if it doesn't have anything left do once microtasks have been processed. As a result, this works fine:</p>
<div class="fragment"><div class="line">const tx = db.transaction(&#39;keyval&#39;, &#39;readwrite&#39;);</div>
<div class="line">const store = tx.objectStore(&#39;keyval&#39;);</div>
<div class="line">const val = (await store.get(&#39;counter&#39;)) || 0;</div>
<div class="line">await store.put(val + 1, &#39;counter&#39;);</div>
<div class="line">await tx.done;</div>
</div><!-- fragment --><p>But this doesn't:</p>
<div class="fragment"><div class="line">const tx = db.transaction(&#39;keyval&#39;, &#39;readwrite&#39;);</div>
<div class="line">const store = tx.objectStore(&#39;keyval&#39;);</div>
<div class="line">const val = (await store.get(&#39;counter&#39;)) || 0;</div>
<div class="line">// This is where things go wrong:</div>
<div class="line">const newVal = await fetch(&#39;/increment?val=&#39; + val);</div>
<div class="line">// And this throws an error:</div>
<div class="line">await store.put(newVal, &#39;counter&#39;);</div>
<div class="line">await tx.done;</div>
</div><!-- fragment --><p>In this case, the transaction closes while the browser is fetching, so <code>store.put</code> fails.</p>
<h2><a class="anchor" id="autotoc_md14714"></a>
<code>IDBDatabase</code> enhancements</h2>
<h3><a class="anchor" id="autotoc_md14715"></a>
Shortcuts to get/set from an object store</h3>
<p>It's common to create a transaction for a single action, so helper methods are included for this:</p>
<div class="fragment"><div class="line">// Get a value from a store:</div>
<div class="line">const value = await db.get(storeName, key);</div>
<div class="line">// Set a value in a store:</div>
<div class="line">await db.put(storeName, value, key);</div>
</div><!-- fragment --><p>The shortcuts are: <code>get</code>, <code>getKey</code>, <code>getAll</code>, <code>getAllKeys</code>, <code>count</code>, <code>put</code>, <code>add</code>, <code>delete</code>, and <code>clear</code>. Each method takes a <code>storeName</code> argument, the name of the object store, and the rest of the arguments are the same as the equivalent <code>IDBObjectStore</code> method.</p>
<h3><a class="anchor" id="autotoc_md14716"></a>
Shortcuts to get from an index</h3>
<p>The shortcuts are: <code>getFromIndex</code>, <code>getKeyFromIndex</code>, <code>getAllFromIndex</code>, <code>getAllKeysFromIndex</code>, and <code>countFromIndex</code>.</p>
<div class="fragment"><div class="line">// Get a value from an index:</div>
<div class="line">const value = await db.getFromIndex(storeName, indexName, key);</div>
</div><!-- fragment --><p>Each method takes <code>storeName</code> and <code>indexName</code> arguments, followed by the rest of the arguments from the equivalent <code>IDBIndex</code> method.</p>
<h2><a class="anchor" id="autotoc_md14717"></a>
<code>IDBTransaction</code> enhancements</h2>
<h3><a class="anchor" id="autotoc_md14718"></a>
<code>tx.store</code></h3>
<p>If a transaction involves a single store, the <code>store</code> property will reference that store.</p>
<div class="fragment"><div class="line">const tx = db.transaction(&#39;whatever&#39;);</div>
<div class="line">const store = tx.store;</div>
</div><!-- fragment --><p>If a transaction involves multiple stores, <code>tx.store</code> is undefined, you need to use <code>tx.objectStore(storeName)</code> to get the stores.</p>
<h3><a class="anchor" id="autotoc_md14719"></a>
<code>tx.done</code></h3>
<p>Transactions have a <code>.done</code> promise which resolves when the transaction completes successfully, and otherwise rejects with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction/error">transaction error</a>.</p>
<div class="fragment"><div class="line">const tx = db.transaction(storeName, &#39;readwrite&#39;);</div>
<div class="line">await Promise.all([</div>
<div class="line">  tx.store.put(&#39;bar&#39;, &#39;foo&#39;),</div>
<div class="line">  tx.store.put(&#39;world&#39;, &#39;hello&#39;),</div>
<div class="line">  tx.done,</div>
<div class="line">]);</div>
</div><!-- fragment --><p>If you're writing to the database, <code>tx.done</code> is the signal that everything was successfully committed to the database. However, it's still beneficial to await the individual operations, as you'll see the error that caused the transaction to fail.</p>
<h2><a class="anchor" id="autotoc_md14720"></a>
<code>IDBCursor</code> enhancements</h2>
<p>Cursor advance methods (<code>advance</code>, <code>continue</code>, <code>continuePrimaryKey</code>) return a promise for the cursor, or null if there are no further values to provide.</p>
<div class="fragment"><div class="line">let cursor = await db.transaction(storeName).store.openCursor();</div>
<div class="line"> </div>
<div class="line">while (cursor) {</div>
<div class="line">  console.log(cursor.key, cursor.value);</div>
<div class="line">  cursor = await cursor.continue();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14721"></a>
Async iterators</h2>
<p>Async iterator support isn't included by default (Edge doesn't support them). To include them, import <code>idb/with-async-ittr</code> instead of <code>idb</code> (this increases the library size to ~1.29kB brotli'd):</p>
<div class="fragment"><div class="line">import { openDB } from &#39;idb/with-async-ittr&#39;;</div>
</div><!-- fragment --><p>Or <code><a href="https://cdn.jsdelivr.net/npm/idb">https://cdn.jsdelivr.net/npm/idb</a>@7/build/umd-with-async-ittr.js</code> if you're using the non-module version.</p>
<p>Now you can iterate over stores, indexes, and cursors:</p>
<div class="fragment"><div class="line">const tx = db.transaction(storeName);</div>
<div class="line"> </div>
<div class="line">for await (const cursor of tx.store) {</div>
<div class="line">  // …</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each yielded object is an <code>IDBCursor</code>. You can optionally use the advance methods to skip items (within an async iterator they return void):</p>
<div class="fragment"><div class="line">const tx = db.transaction(storeName);</div>
<div class="line"> </div>
<div class="line">for await (const cursor of tx.store) {</div>
<div class="line">  console.log(cursor.value);</div>
<div class="line">  // Skip the next item</div>
<div class="line">  cursor.advance(2);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you don't manually advance the cursor, <code>cursor.continue()</code> is called for you.</p>
<p>Stores and indexes also have an <code>iterate</code> method which has the same signature as <code>openCursor</code>, but returns an async iterator:</p>
<div class="fragment"><div class="line">const index = db.transaction(&#39;books&#39;).store.index(&#39;author&#39;);</div>
<div class="line"> </div>
<div class="line">for await (const cursor of index.iterate(&#39;Douglas Adams&#39;)) {</div>
<div class="line">  console.log(cursor.value);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14722"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md14723"></a>
Keyval store</h2>
<p>This is very similar to <code>localStorage</code>, but async. If this is <em>all</em> you need, you may be interested in <a href="https://www.npmjs.com/package/idb-keyval">idb-keyval</a>. You can always upgrade to this library later.</p>
<div class="fragment"><div class="line">import { openDB } from &#39;idb&#39;;</div>
<div class="line"> </div>
<div class="line">const dbPromise = openDB(&#39;keyval-store&#39;, 1, {</div>
<div class="line">  upgrade(db) {</div>
<div class="line">    db.createObjectStore(&#39;keyval&#39;);</div>
<div class="line">  },</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">export async function get(key) {</div>
<div class="line">  return (await dbPromise).get(&#39;keyval&#39;, key);</div>
<div class="line">}</div>
<div class="line">export async function set(key, val) {</div>
<div class="line">  return (await dbPromise).put(&#39;keyval&#39;, val, key);</div>
<div class="line">}</div>
<div class="line">export async function del(key) {</div>
<div class="line">  return (await dbPromise).delete(&#39;keyval&#39;, key);</div>
<div class="line">}</div>
<div class="line">export async function clear() {</div>
<div class="line">  return (await dbPromise).clear(&#39;keyval&#39;);</div>
<div class="line">}</div>
<div class="line">export async function keys() {</div>
<div class="line">  return (await dbPromise).getAllKeys(&#39;keyval&#39;);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14724"></a>
Article store</h2>
<div class="fragment"><div class="line">import { openDB } from &#39;idb/with-async-ittr.js&#39;;</div>
<div class="line"> </div>
<div class="line">async function demo() {</div>
<div class="line">  const db = await openDB(&#39;Articles&#39;, 1, {</div>
<div class="line">    upgrade(db) {</div>
<div class="line">      // Create a store of objects</div>
<div class="line">      const store = db.createObjectStore(&#39;articles&#39;, {</div>
<div class="line">        // The &#39;id&#39; property of the object will be the key.</div>
<div class="line">        keyPath: &#39;id&#39;,</div>
<div class="line">        // If it isn&#39;t explicitly set, create a value by auto incrementing.</div>
<div class="line">        autoIncrement: true,</div>
<div class="line">      });</div>
<div class="line">      // Create an index on the &#39;date&#39; property of the objects.</div>
<div class="line">      store.createIndex(&#39;date&#39;, &#39;date&#39;);</div>
<div class="line">    },</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  // Add an article:</div>
<div class="line">  await db.add(&#39;articles&#39;, {</div>
<div class="line">    title: &#39;Article 1&#39;,</div>
<div class="line">    date: new Date(&#39;2019-01-01&#39;),</div>
<div class="line">    body: &#39;…&#39;,</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  // Add multiple articles in one transaction:</div>
<div class="line">  {</div>
<div class="line">    const tx = db.transaction(&#39;articles&#39;, &#39;readwrite&#39;);</div>
<div class="line">    await Promise.all([</div>
<div class="line">      tx.store.add({</div>
<div class="line">        title: &#39;Article 2&#39;,</div>
<div class="line">        date: new Date(&#39;2019-01-01&#39;),</div>
<div class="line">        body: &#39;…&#39;,</div>
<div class="line">      }),</div>
<div class="line">      tx.store.add({</div>
<div class="line">        title: &#39;Article 3&#39;,</div>
<div class="line">        date: new Date(&#39;2019-01-02&#39;),</div>
<div class="line">        body: &#39;…&#39;,</div>
<div class="line">      }),</div>
<div class="line">      tx.done,</div>
<div class="line">    ]);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // Get all the articles in date order:</div>
<div class="line">  console.log(await db.getAllFromIndex(&#39;articles&#39;, &#39;date&#39;));</div>
<div class="line"> </div>
<div class="line">  // Add &#39;And, happy new year!&#39; to all articles on 2019-01-01:</div>
<div class="line">  {</div>
<div class="line">    const tx = db.transaction(&#39;articles&#39;, &#39;readwrite&#39;);</div>
<div class="line">    const index = tx.store.index(&#39;date&#39;);</div>
<div class="line"> </div>
<div class="line">    for await (const cursor of index.iterate(new Date(&#39;2019-01-01&#39;))) {</div>
<div class="line">      const article = { ...cursor.value };</div>
<div class="line">      article.body += &#39; And, happy new year!&#39;;</div>
<div class="line">      cursor.update(article);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    await tx.done;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14725"></a>
TypeScript</h1>
<p>This library is fully typed, and you can improve things by providing types for your database:</p>
<div class="fragment"><div class="line">import { openDB, DBSchema } from &#39;idb&#39;;</div>
<div class="line"> </div>
<div class="line">interface MyDB extends DBSchema {</div>
<div class="line">  &#39;favourite-number&#39;: {</div>
<div class="line">    key: string;</div>
<div class="line">    value: number;</div>
<div class="line">  };</div>
<div class="line">  products: {</div>
<div class="line">    value: {</div>
<div class="line">      name: string;</div>
<div class="line">      price: number;</div>
<div class="line">      productCode: string;</div>
<div class="line">    };</div>
<div class="line">    key: string;</div>
<div class="line">    indexes: { &#39;by-price&#39;: number };</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">async function demo() {</div>
<div class="line">  const db = await openDB&lt;MyDB&gt;(&#39;my-db&#39;, 1, {</div>
<div class="line">    upgrade(db) {</div>
<div class="line">      db.createObjectStore(&#39;favourite-number&#39;);</div>
<div class="line"> </div>
<div class="line">      const productStore = db.createObjectStore(&#39;products&#39;, {</div>
<div class="line">        keyPath: &#39;productCode&#39;,</div>
<div class="line">      });</div>
<div class="line">      productStore.createIndex(&#39;by-price&#39;, &#39;price&#39;);</div>
<div class="line">    },</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  // This works</div>
<div class="line">  await db.put(&#39;favourite-number&#39;, 7, &#39;Jen&#39;);</div>
<div class="line">  // This fails at compile time, as the &#39;favourite-number&#39; store expects a number.</div>
<div class="line">  await db.put(&#39;favourite-number&#39;, &#39;Twelve&#39;, &#39;Jake&#39;);</div>
<div class="line">}</div>
</div><!-- fragment --><p>To define types for your database, extend <code>DBSchema</code> with an interface where the keys are the names of your object stores.</p>
<p>For each value, provide an object where <code>value</code> is the type of values within the store, and <code>key</code> is the type of keys within the store.</p>
<p>Optionally, <code>indexes</code> can contain a map of index names, to the type of key within that index.</p>
<p>Provide this interface when calling <code>openDB</code>, and from then on your database will be strongly typed. This also allows your IDE to autocomplete the names of stores and indexes.</p>
<h2><a class="anchor" id="autotoc_md14726"></a>
Opting out of types</h2>
<p>If you call <code>openDB</code> without providing types, your database will use basic types. However, sometimes you'll need to interact with stores that aren't in your schema, perhaps during upgrades. In that case you can cast.</p>
<p>Let's say we were renaming the 'favourite-number' store to 'fave-nums':</p>
<div class="fragment"><div class="line">import { openDB, DBSchema, IDBPDatabase } from &#39;idb&#39;;</div>
<div class="line"> </div>
<div class="line">interface MyDBV1 extends DBSchema {</div>
<div class="line">  &#39;favourite-number&#39;: { key: string; value: number };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface MyDBV2 extends DBSchema {</div>
<div class="line">  &#39;fave-num&#39;: { key: string; value: number };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const db = await openDB&lt;MyDBV2&gt;(&#39;my-db&#39;, 2, {</div>
<div class="line">  async upgrade(db, oldVersion) {</div>
<div class="line">    // Cast a reference of the database to the old schema.</div>
<div class="line">    const v1Db = db as unknown as IDBPDatabase&lt;MyDBV1&gt;;</div>
<div class="line"> </div>
<div class="line">    if (oldVersion &lt; 1) {</div>
<div class="line">      v1Db.createObjectStore(&#39;favourite-number&#39;);</div>
<div class="line">    }</div>
<div class="line">    if (oldVersion &lt; 2) {</div>
<div class="line">      const store = v1Db.createObjectStore(&#39;favourite-number&#39;);</div>
<div class="line">      store.name = &#39;fave-num&#39;;</div>
<div class="line">    }</div>
<div class="line">  },</div>
<div class="line">});</div>
</div><!-- fragment --><p>You can also cast to a typeless database by omitting the type, eg <code>db as IDBPDatabase</code>.</p>
<p>Note: Types like <code>IDBPDatabase</code> are used by TypeScript only. The implementation uses proxies under the hood.</p>
<h1><a class="anchor" id="autotoc_md14727"></a>
Developing</h1>
<div class="fragment"><div class="line">npm run dev</div>
</div><!-- fragment --><p>This will also perform type testing.</p>
<p>To test, navigate to <code>build/test/</code> in a browser. You'll need to set up a <a href="https://www.npmjs.com/package/serve">basic web server</a> for this. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
