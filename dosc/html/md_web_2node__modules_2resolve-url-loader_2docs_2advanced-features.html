<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AREA: Advanced Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AREA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Advanced Features</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md21819"></a> All the advanced features of this loader involve customising the <code>join</code> option.</p>
<p>Jump to the **"how to"** section -</p><ul>
<li>How to: change precedence of source locations</li>
<li>How to: fallback to a theme or other global directory</li>
<li>How to: fallback to some other asset file</li>
<li>How to: perform a file-system search for an asset</li>
</ul>
<h1><a class="anchor" id="autotoc_md21820"></a>
What is the "join" function?</h1>
<p>The "join" function determines how CSS URIs are combined with one of the possible base paths the algorithm has identified.</p>
<p>‚ö†Ô∏è <b>IMPORTANT</b> - First read how the <a href="./how-it-works.md#algorithm">algorithm</a> works.</p>
<p>The "join" function is a higher-order function created using the <code>options</code> and <code>loader</code> reference. That gives a function that accepts a single <code>item</code> and synchronously returns an absolute asset path to substitute back into the original CSS.</p>
<div class="fragment"><div class="line">(options:{}, loader:{}) =&gt;</div>
<div class="line">  (item:{ uri:string, query: string, isAbsolute: boolean, bases:{} }) =&gt;</div>
<div class="line">    string | null</div>
</div><!-- fragment --><p>Where the <code>bases</code> are absolute directory paths <code>{ subString, value, property, selector }</code> per the <a href="./how-it-works.md#algorithm">algorithm</a>. Note that returning <code>null</code> implies no substitution, the original relative <code>uri</code> is retained.</p>
<p>The job of the "join" function is to consider possible locations for the asset based on the <code>bases</code> and determine which is most appropriate. This implies some order of precedence in these locations and some file-system operation to determine if the asset there.</p>
<p>The default implementation is suitable for most users but can be customised per the <code>join</code> option.</p>
<p>A custom <code>join</code> function from scratch is possible but we've provided some building blocks to make the task easier.</p>
<h1><a class="anchor" id="autotoc_md21821"></a>
Building blocks</h1>
<p>There are a number of utilities (defined in <a href="../lib/join-function/index.js"><code>lib/join-function/index.js</code></a>) to help construct a custom "join" function . These are conveniently re-exported as properties of the loader.</p>
<p>These utilities are used to create the <code>defaultJoin</code> as follows.</p>
<div class="fragment"><div class="line">const {</div>
<div class="line">  createJoinFunction,</div>
<div class="line">  createJoinImplementation,</div>
<div class="line">  defaultJoinGenerator,</div>
<div class="line">} = require(&#39;resolve-url-loader&#39;);</div>
<div class="line"> </div>
<div class="line">// create a join function equivalent to &quot;defaultJoin&quot;</div>
<div class="line">const myJoinFn = createJoinFunction(</div>
<div class="line">  &#39;myJoinFn&#39;,</div>
<div class="line">  createJoinImplementation(defaultJoinGenerator),</div>
<div class="line">});</div>
</div><!-- fragment --><p>ü§ì If you have some very specific behaviour in mind you can specify your own implementation. This gives full control but still gives you <code>debug</code> logging for free.</p>
<div class="fragment"><div class="line">createJoinFunction = (name:string, implementation: function): function</div>
</div><!-- fragment --><p>For each item, the implementation needs to make multiple attempts at locating the asset. It has mixed concerns of itentifying locations to search and then evaluating those locates one by one.</p>
<p>üëâ However its recommended to instead use <code>createJoinImplementation</code> to create the <code>implementation</code> using the <code>generator</code> concept.</p>
<div class="fragment"><div class="line">createJoinImplementation = (generator: function*): function</div>
</div><!-- fragment --><p>The <code>generator</code> has the single concern of identifying locations to search. The work of searching these locations is done by <code>createJoinImplementation</code>. Overall this means less boilerplate code for you to write.</p>
<p>Don't worry, you don't need to use <code>function*</code> semantics for the <code>generator</code> unless you want to.</p>
<h1><a class="anchor" id="autotoc_md21822"></a>
Simple customisation</h1>
<p>It is relatively simple to change the precedence of values (from the <a href="./how-it-works.md#algorithm">algorithm</a>) or add further locations to search for an asset. To do this we use <code>createJoinImplementation</code> and write a custom <code>generator</code>.</p>
<p>See the reference or jump directly to the examples.</p>
<h2><a class="anchor" id="autotoc_md21823"></a>
Reference</h2>
<p>The <code>generator</code> identifies <code>[base:string,uri:string]</code> tuples describing locations to search for an asset. It does <b>not</b> return the final asset path.</p>
<p>You may lazily generate tuples as <code>Iterator</code>. Refer to this <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">guide on Iterators and Generators</a>. </p><div class="fragment"><div class="line">generator = function* (item: {}, options: {}, loader: {}): Iterator&lt;[string,string]&gt;</div>
</div><!-- fragment --><p>Or it can be simpler to write a function that returns <code>Array</code> and convert it to a generator using <code>asGenerator</code>.</p>
<div class="fragment"><div class="line">generator = asGenerator( function (item: {}, options: {}, loader: {}): Array&lt;string&gt; )</div>
</div><!-- fragment --> <div class="fragment"><div class="line">generator = asGenerator( function (item: {}, options: {}, loader: {}): Array&lt;[string,string]&gt; )</div>
</div><!-- fragment --><p>When using <code>asGenerator</code> you may return elements as either <code>base:string</code> <b>or</b> <code>[base:string,uri:string]</code> tuples.</p>
<details >
<summary >
Arguments</summary>
<p></p>
<ul>
<li><code>item</code> consist of -<ul>
<li><code>uri: string</code> is the argument to the <code>url()</code> as it appears in the source file.</li>
<li><code>query: string</code> is any query or hash string starting with <code>?</code> or <code>#</code> that suffixes the <code>uri</code></li>
<li><code>isAbsolute: boolean</code> flag indicates whether the URI is considered an absolute file or root relative path by webpack's definition. Absolute URIs are only processed if the <code>root</code> option is specified.</li>
<li><code>bases: {}</code> are a hash where the keys are the sourcemap evaluation locations in the <a href="./how-it-works.md#algorithm">algorithm</a> and the values are absolute paths that the sourcemap reports. These directories might not actually exist.</li>
</ul>
</li>
<li><code>options</code> consist of -<ul>
<li>All documented options for the loader.</li>
<li>Any other values you include in the loader configuration for your own purposes.</li>
</ul>
</li>
<li><code>loader</code> consists of the webpack loader API, useful items include -<ul>
<li><code>fs: {}</code> the virtual file-system from Webpack.</li>
<li><code>resourcePath: string</code> the source file currently being processed.</li>
</ul>
</li>
<li>returns an <code>Iterator</code> with elements of <code>[base:string,uri:string]</code> either intrinsically or by using <code>asGenerator</code>. </li>
</ul>
</details>
<details >
<summary >
FAQ</summary>
<p></p>
<ul>
<li><p class="startli"><b>Why a tuple?</b></p>
<p class="startli">The primary pupose of this loader is to find the correct <code>base</code> path for your <code>uri</code>. By returning a list of paths to search we can better generate <code>debug</code> logging.</p>
<p class="startli">That said there are cases where you might want to amend the <code>uri</code>. The solution is to make each element a tuple of <code>base</code> and <code>uri</code> representing a potential location to find the asset.</p>
<p class="startli">If you're interested only in the <code>base</code> path and don't intend to vary the <code>uri</code> then the <code>asGenerator</code> utility saves you having to create repetative tuples (and from using <code>function*</code> semantics).</p>
</li>
<li><p class="startli"><b>Can I vary the <code>query</code> using the tuple?</b></p>
<p class="startli">No. We don't support amending the <code>query</code> in the final value. If you would like this enhancement please open an issue.</p>
</li>
<li><p class="startli"><b>What about duplicate or falsey elements?</b></p>
<p class="startli">The <code>createJoinImplementation</code> will eliminate any invalid elements regardless of whether you use <code>Array</code> or <code>Iterator</code>. This makes it possible to <code>&amp;&amp;</code> elements inline with a predicate value.</p>
<p class="startli">If you use <code>Array</code> then <code>asGenerator</code> will also remove duplicates.</p>
</li>
<li><p class="startli"><b>When should I use <code>function*</code>?</b></p>
<p class="startli">If you need lazy generation of values then you may return <code>Iterator</code> or use <code>function*</code> semantics. Refer to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">this guide on Iterators</a>.</p>
<p class="startli">But in most cases, when the values are known apriori, simply returning <code>Array</code> has simpler semantics making <code>asGenerator</code> preferable.</p>
</li>
<li><p class="startli"><b>Why is this generator so complicated?</b></p>
<p class="startli">The join function must make multiple attempts to join a <code>base</code> and <code>uri</code> and check that the file exists using webpack <code>fs</code>.</p>
<p class="startli">The <code>generator</code> is focussed on identifying locations to search. It is a more scalable concept where you wish to search many places. The traditional use case for the custom "join" function is a file-system search so the <code>generator</code> was designed to make this possible.</p>
<p class="startli">If you prefer a less abstract approach consider a full <code>implementation</code> per the full customisation approach. </p>
</li>
</ul>
</details>
<h2><a class="anchor" id="autotoc_md21824"></a>
How to: change precedence of source locations</h2>
<p>Source-map sampling is limited to the locations defined in the <a href="./how-it-works.md#algorithm">algorithm</a>. You can't change these locations but you can preference them in a different order.</p>
<p>This example shows the default order which you can easily amend. Absolute URIs are rare in most projects but can be handled for completeness.</p>
<p><b>Using <code>asGenerator</code></b></p>
<div class="fragment"><div class="line">const {</div>
<div class="line">  createJoinFunction,</div>
<div class="line">  createJoinImplementation,</div>
<div class="line">  asGenerator,</div>
<div class="line">  defaultJoinGenerator,</div>
<div class="line">} = require(&#39;resolve-url-loader&#39;);</div>
<div class="line"> </div>
<div class="line">// order source-map sampling location by your preferred precedence (matches defaultJoinGenerator)</div>
<div class="line">const myGenerator = asGenerator(</div>
<div class="line">  ({ isAbsolute, bases: { substring, value, property, selector} }, { root }) =&gt;</div>
<div class="line">    isAbsolute ? [root] : [subString, value, property, selector]</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">const myJoinFn = createJoinFunction(</div>
<div class="line">  &#39;myJoinFn&#39;,</div>
<div class="line">  createJoinImplementation(myGenerator),</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Notes</b></p>
<ul>
<li>The implementation is the default behaviour, so if you want this precedence do <b>not</b> customise the <code>join</code> option.</li>
<li>Absolute URIs generally use the base path given in the <code>root</code> option as shown.</li>
<li>The <code>asGenerator</code> utility allows us to return simple <code>Array&lt;string&gt;</code> of potential base paths.</li>
</ul>
<h2><a class="anchor" id="autotoc_md21825"></a>
How to: fallback to a theme or other global directory</h2>
<p>Additional locations can be added by decorating the default generator. This is popular for adding some sort of "theme" directory containing assets.</p>
<p>This example appends a static theme directory as a fallback location where the asset might reside. Absolute URIs are rare in most projects but can be handled for completeness.</p>
<p><b>Using <code>asGenerator</code></b></p>
<div class="fragment"><div class="line">const path = require(&#39;path&#39;);</div>
<div class="line">const {</div>
<div class="line">  createJoinFunction,</div>
<div class="line">  createJoinImplementation,</div>
<div class="line">  asGenerator,</div>
<div class="line">  defaultJoinGenerator,</div>
<div class="line">} = require(&#39;resolve-url-loader&#39;);</div>
<div class="line"> </div>
<div class="line">const myThemeDirectory = path.resolve(...);</div>
<div class="line"> </div>
<div class="line">// call default generator then append any additional paths</div>
<div class="line">const myGenerator = asGenerator(</div>
<div class="line">  (item, ...rest) =&gt; [</div>
<div class="line">    ...defaultJoinGenerator(item, ...rest),</div>
<div class="line">    item.isAbsolute ? null : myThemeDirectory,</div>
<div class="line">  ]</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">const myJoinFn = createJoinFunction(</div>
<div class="line">  &#39;myJoinFn&#39;,</div>
<div class="line">  createJoinImplementation(myGenerator),</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Notes</b></p>
<ul>
<li>By spreading the result of <code>defaultJoinGenerator</code> we are first trying the default behaviour. If that is unsuccessful we then try the theme location.</li>
<li>It's assumed that theming doesn't apply to absolute URIs. Since falsey elements are ignored we can easily <code>null</code> the additional theme element inline as shown.</li>
<li>The <code>asGenerator</code> utility allows us to return simple <code>Array&lt;string&gt;</code> of potential base paths.</li>
</ul>
<h2><a class="anchor" id="autotoc_md21826"></a>
How to: fallback to some other asset file</h2>
<p>Lets imagine we don't have high quality files for all our assets and must sometimes use a lower quality format. For each item we need to try the <code>uri</code> with different file extensions. We can do this by returning tuples of <code>[base:string,uri:string]</code>.</p>
<p>In this example we prefer the <code>.svg</code> asset we are happy to use any available <code>.png</code> or <code>.jpg</code> instead.</p>
<p><b>Using <code>asGenerator</code></b></p>
<div class="fragment"><div class="line">const {</div>
<div class="line">  createJoinFunction,</div>
<div class="line">  createJoinImplementation,</div>
<div class="line">  asGenerator,</div>
<div class="line">  defaultJoinGenerator,</div>
<div class="line">} = require(&#39;resolve-url-loader&#39;);</div>
<div class="line"> </div>
<div class="line">// call default generator then pair different variations of uri with each base</div>
<div class="line">const myGenerator = asGenerator(</div>
<div class="line">  (item, ...rest) =&gt; {</div>
<div class="line">    const defaultTuples = [...defaultJoinGenerator(item, ...rest)];</div>
<div class="line">    return /\.svg$/.test(item.uri)</div>
<div class="line">      ? [&#39;.svg&#39;, &#39;.png&#39;, &#39;jpg&#39;].flatMap((ext) =&gt;</div>
<div class="line">          defaultTuples.flatMap(([base, uri]) =&gt;</div>
<div class="line">            [base, uri.replace(/\.svg$/, ext)]</div>
<div class="line">          })</div>
<div class="line">        )</div>
<div class="line">      : defaultTuples;</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">const myJoinFn = createJoinFunction(</div>
<div class="line">  &#39;myJoinFn&#39;,</div>
<div class="line">  createJoinImplementation(myGenerator),</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Using <code>function*</code></b></p>
<div class="fragment"><div class="line">const {</div>
<div class="line">  createJoinFunction,</div>
<div class="line">  createJoinImplementation,</div>
<div class="line">  defaultJoinGenerator,</div>
<div class="line">} = require(&#39;resolve-url-loader&#39;);</div>
<div class="line"> </div>
<div class="line">// call default generator then pair different variations of uri with each base</div>
<div class="line">const myGenerator = function* (item, ...rest) {</div>
<div class="line">  if (/\.svg$/.test(item.uri)) {</div>
<div class="line">    for (let ext of [&#39;.svg&#39;, &#39;.png&#39;, &#39;jpg&#39;]) {</div>
<div class="line">      for (let [base, uri] of defaultJoinGenerator(item, ...rest)) {</div>
<div class="line">        yield [base, uri.replace(/\.svg$/, ext)];</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } else {</div>
<div class="line">    for (let value of defaultJoinGenerator(item, ...rest)) {</div>
<div class="line">      yield value;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const myJoinFn = createJoinFunction(</div>
<div class="line">  &#39;myJoinFn&#39;,</div>
<div class="line">  createJoinImplementation(myGenerator),</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Notes</b></p>
<ul>
<li>Existing generators such as <code>defaultJoinGenerator</code> will always return <code>[string,string]</code> tuples so we can destruture <code>base</code> and <code>uri</code> values with confidence.</li>
<li>This implementation attempts all extensions for a given <code>base</code> before moving to the next <code>base</code>. Obviously we may change the nesting and instead do the oposite, attempt all bases for a single extension before moving on to the next extension</li>
<li>The <code>asGenerator</code> utility allows us to return <code>Array&lt;[string, string]&gt;</code> but is <b>not</b> needed when we use <code>function*</code> semantics.</li>
</ul>
<h2><a class="anchor" id="autotoc_md21827"></a>
How to: perform a file-system search for an asset</h2>
<p>‚ö†Ô∏è <b>IMPORTANT</b> - This example is indicative only and is <b>not</b> advised.</p>
<p>When this loader was originally released it was very common for packages be broken to the point that a full file search was needed to locate assets referred to in CSS. While this was not performant some users really liked it. By customising the <code>generator</code> we can once again lazily search the file-system.</p>
<p>In this example we search the parent directories of the base paths, continuing upwards until we hit a package boundary. Absolute URIs are rare in most projects but can be handled for completeness.</p>
<p><b>Using <code>function*</code></b></p>
<div class="fragment"><div class="line">const path = require(&#39;path&#39;);</div>
<div class="line">const {</div>
<div class="line">  createJoinFunction,</div>
<div class="line">  createJoinImplementation,</div>
<div class="line">  webpackExistsSync</div>
<div class="line">} = require(&#39;resolve-url-loader&#39;);</div>
<div class="line"> </div>
<div class="line">// search up from the initial base path until you hit a package boundary</div>
<div class="line">const myGenerator = function* (</div>
<div class="line">  { uri, isAbsolute, bases: { substring, value, property, selector } },</div>
<div class="line">  { root, attempts = 1e3 },</div>
<div class="line">  { fs },</div>
<div class="line">) {</div>
<div class="line">  if (isAbsolute) {</div>
<div class="line">    yield [root, uri];</div>
<div class="line">  } else {</div>
<div class="line">    for (let base of [subString, value, property, selector]) {</div>
<div class="line">       for (let isDone = false, i = 0; !isDone &amp;&amp; i &lt; attempts; i++) {</div>
<div class="line">          yield [base, uri];</div>
<div class="line">          // unfortunately fs.existsSync() is not present so we must shim it</div>
<div class="line">          const maybePkg = path.normalize(path.join(base, &#39;package.json&#39;));</div>
<div class="line">          try {</div>
<div class="line">            isDone = fs.statSync(maybePkg).isFile();</div>
<div class="line">          } catch (error) {</div>
<div class="line">            isDone = false;</div>
<div class="line">          }</div>
<div class="line">          base = base.split(/(\\\/)/).slice(0, -2).join(&#39;&#39;);</div>
<div class="line">       }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const myJoinFn = createJoinFunction(</div>
<div class="line">  &#39;myJoinFn&#39;,</div>
<div class="line">  createJoinImplementation(myGenerator),</div>
<div class="line">);</div>
</div><!-- fragment --><p><b>Notes</b></p>
<ul>
<li>This implementation is nether tested nor robust, it would need further safeguards to avoid searching the entire file system.</li>
<li>By using <code>function*</code> the generator is lazy. We only walk the file-system directory tree as necessary.</li>
<li>The webpack file-system is provided by the <code>enhanced-resolver-plugin</code> and does <b>not</b> contain <code>fs.existsSync()</code>. We must use <code>fs.statsSync()</code> instead and catch any error where the file isn't present.</li>
<li>You may set additional <code>options</code> when you configure the loader in webpack and then access them in your <code>generator</code>. In this case we add an <code>attempts</code> option to limit the file search.</li>
</ul>
<h1><a class="anchor" id="autotoc_md21828"></a>
Full customisation</h1>
<p>The <code>createJoinFunction</code> can give you full control over how the <code>base</code> and <code>uri</code> are joined to create an absolute file path <b>and</b> the definitiion of success for that combination.</p>
<p>It provides additional logging when using <code>debug</code> option so is a better choice then writing a "join" function from scratch.</p>
<p>Limited documentation is given here since it is rare to require a full customisation. Refer to the source code for further information.</p>
<h2><a class="anchor" id="autotoc_md21829"></a>
Reference</h2>
<p>The <code>implementation</code> synchronously returns the final asset path or some fallback value. It makes a number of attempts to search for the given item and returns an element describing each attempt.</p>
<div class="fragment"><div class="line">implementation = function (item: {}, options: {}, loader: {}):</div>
<div class="line">  Array&lt;{</div>
<div class="line">    base      : string,</div>
<div class="line">    uri       : string,</div>
<div class="line">    joined    : string,</div>
<div class="line">    isSuccess : boolean,</div>
<div class="line">    isFallback: boolean,</div>
<div class="line">  }&gt;</div>
</div><!-- fragment --> <details >
<summary >
Arguments</summary>
<p></p>
<ul>
<li><code>item</code> consist of -<ul>
<li><code>uri: string</code> is the argument to the <code>url()</code> as it appears in the source file.</li>
<li><code>query: string</code> is any string starting with <code>?</code> or <code>#</code> that suffixes the <code>uri</code></li>
<li><code>isAbsolute: boolean</code> flag indicates whether the URI is considered an absolute file or root relative path by webpack's definition. Absolute URIs are only processed if the <code>root</code> option is specified.</li>
<li><code>bases: {}</code> are a hash where the keys are the sourcemap evaluation locations in the <a href="./how-it-works.md#algorithm">algorithm</a> and the values are absolute paths that the sourcemap reports. These directories might not actually exist.</li>
</ul>
</li>
<li><code>options</code> consist of -<ul>
<li>All documented options for the loader.</li>
<li>Any other values you include in the loader configuration for your own purposes.</li>
</ul>
</li>
<li><code>loader</code> consists of the webpack loader API, useful items include -<ul>
<li><code>fs: {}</code> the virtual file-system from Webpack.</li>
<li><code>resourcePath: string</code> the source file currently being processed.</li>
</ul>
</li>
<li>returns an array of attempts that were made in resolving the URI -<ul>
<li><code>base</code> the base path</li>
<li><code>uri</code> the uri path</li>
<li><code>joined</code> the absolute path created from the joining the <code>base</code> and <code>uri</code> paths.</li>
<li><code>isSuccess</code> indicates the asset was found and that <code>joined</code> should be the final result</li>
<li><code>isFallback</code> indicates the asset was not found but that <code>joined</code> kis suitable as a fallback value </li>
</ul>
</li>
</ul>
</details>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
